# JVM

![image](https://user-images.githubusercontent.com/57666307/162567385-d4034ef9-e4cd-4b24-a332-10db3558430c.png)


### JVM(Java Virtual Machine)
자바 가상 머신으로 자바 바이트 코드(.class 파일)을 OS에 특화된 코드로 변환(인터프리터와 JIT 컴파일러)하여 실행한다.

여담으로  **JRE**는 자바 어플리케이션을 실행할 수 있도록 하는 배포판이다.(개발 관련도구는 **JDK**에서 제공한다.) 자바 유료화에 대한 말이 있는데 이 의미는 
오라클에서 만든 Oracle JDK 11 버전부터 상용으로 사용할떄 유료라고 한다. 

**자바**는 프로그래밍 언어이고, JDK에 들어있는 자바 컴파일러(javac)를 사용하여 바이트코드(.class 파일)로 컴파일 할 수 있다.

## JVM구조
![image](https://user-images.githubusercontent.com/57666307/162567092-890cbcc8-aa7d-429f-ad1a-095c5bf0a75a.png)

### 클래스 로더 시스템
  - .class에서 바이트코드를 읽고 메모리에 저장하는 과정이다.
  - 로딩, 링크, 초기화 순으로 진행된다.
  - 로딩은 클래스 로더가 .class 파일을 읽고 그 내용에 따라 적절한 바이너리 데이터를 만들고 **메소드** 영역에 저장.
  - 로딩이 끝나면 해당 클래스 타입의 Class 객체를 생성해서 **힙**영역에 저장한다.

### 메모리
  - **메모스 영역에**에는 클래스 수준의 정보 (클래스 이름, 부모 클래스 이름, 메소드, 변수) 저장하며 공유 자원이다.
  - **힙 영역**에는 객체를 저장하며 공유 자원이다.
  - **스택 영역에**는 쓰레드 마다 런타임 스택을 만들고, 그 안에 메소드 호출을 스택 프레임이라 부르는 블럭으로 쌓는다. 쓰레드를 종료하면 런타임 스택도 사라진다.
  - **PC(Program Counter) 레지스터**는 쓰레드 마다 쓰레드 내 현재 실행할 스택 프레임을 가리키는 포인터가 생성된다.
  - **네이티브 메소드 스택**

### 실행 엔진

 - **인터프리터**는 바이크 코드를 한줄 씩 실행한다.
 - **JIT 컴파일러**는 인터프리터 효율을 높이기 위해, 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러로 반복되는 코드를 모두 네이티브 코드로 바꿔둔다. 
 - 그 다음부터 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용한다.
 - **GC(Garbage Collector)**는 더이상 참조되지 않는 객체를 모아서 정리한다.
