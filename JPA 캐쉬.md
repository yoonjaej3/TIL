## JPA캐쉬



### 캐쉬 사용하는 이유
네트워크를 통해 데이터베이스에 접근하는 시간 비용은 애플리케이션 서버에서 내부 메모리에 접근하는 시간 비용보다 수만에서 수십만 배 이상 비쌉니다. 
따라서 조회한 데이터를 메모리에 캐시해서 데이터베이스 접근 횟수를 줄이면 애플리케이션 성능을 획기적으로 개선할 수 있습니다.
 

### 1차 캐쉬
![image](https://user-images.githubusercontent.com/57666307/178902611-433019c1-7ab7-4d23-9f08-dc2b4109e452.png)

- 일반적인 웹 애플리케이션 환경은 트랜잭션이 시작하고 종료할 때 까지만 1차 캐시가 유효합니다.
- OSIV를 사용해도 클라이언트의 요청이 들어올 때부터 끝날때 까지만 1차 캐시가 유효합니다.
- 영속성 컨텍스트 내부에는 엔티티를 보관하는 저장소가 있는데, 이를 1차 캐시라고 합니다.
- 1차 캐시는 영속성 컨텍스트 내부에 있습니다. 엔티니 매니저로 조회하거나 변경하는 모든 엔티티는 1차 캐시에 저장됩니다.

### 2차 캐쉬

- 애플리케이션에서 공유하는 캐시를 JPA는 공유 캐시(Shared Cache)라 하는데 일반적으로 2차 캐시 (Second Level Cache, L2 Cache)라 부릅니다. 
- 2차 캐시는 애플리케이션 범위의 캐시입니다. 따라서 애플리케이션을 종료할 때까지 캐시가 유지됩니다. 
  분산 캐시나 클러스터링 환경의 캐시는 애플리케이션보다 더 오래 유지 될 수도 있습니다.


![image](https://user-images.githubusercontent.com/57666307/178902924-be986430-4d27-4ee6-b541-cc76eb02b9a5.png)


### 동작방식

1. 영속성 컨텍스트는 엔티티가 필요하면 2차 캐시를 조회합니다.
2. 2차 캐시에 엔티티가 없으면 데이터베이스를 조회합니다.
3. 결과를 2차 캐시에 보관합니다.
4. 2차 캐시는 자신이 보관하고 있는 엔티티를 복사해서 반환합니다.
5. 2차 캐시에 저장되어 있는 엔티티를 조회하면 복사본을 만들어 반환합니다.
6. 2차 캐시는 데이터베이스 기본 키를 기준으로 캐시하지만 영속성 컨텍스트가 다르면 객체 동일성 (a == b)을 보장하지 않습니다.


![image](https://user-images.githubusercontent.com/57666307/178682502-53896543-ae9c-463d-afd1-370ccf1dd275.png)
