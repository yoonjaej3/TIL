![image](https://user-images.githubusercontent.com/57666307/166909435-8b548138-c32e-4f76-956a-df1ac12be796.png)

Java에는 static이라는 키워드가 존재하며, 이는 static으로 지시된 특정한 멤버가 해당 클래스의 인스턴스가 아니라 클래스 자체에 속해 있음을 나타냅니다. 
즉, 클래스의 모든 인스턴스에서 공유되는 단 하나의 static member의 인스턴스가 생성되도록 명령하는 키워드입니다. 


### 전체 프로그램과 동일한 라이프사이클

 - static 멤버는 사용을 하던 사용하지 않던 프로그램의 시작과 끝까지 메모리 내에 존재합니다. 

 

### static 변수의 생성과 소멸을 지시할 수 없음

- 프로그램이 로딩될 때 생성되고, 프로그램이 종료되거나 JVM이 내려갈 때 소멸됩니다. 개발자가 프로그램적으로 생성과 소멸에 관여할 수 없습니다. 

 

### thread safe하지 않음

- 프로그램 전역에서 사용되기 때문에 모든 스레드에서 static 필드를 공유하게 됩니다. 이때 한 스레드에서 값을 변경할 경우 다른 모든 스레드에서 영향을 받습니다. 이는 동시성 문제를 야기합니다. 

 

### thread safe하게 만들기 위해 추가적인 작업 필요

- 전역으로 관리되기 때문에 기본적으로 thread safety하지 않으며, synchronize를 사용하여 이를 보장하기 위해서는 추가적인 작업이 필요합니다. 

 

### 메모리 문제 

- static 멤버는 프로그램이 종료될 때까지 Garbage Collector로 회수되지 않기 때문에, 많은 수의 static 필드나 메서드가 존재할 경우 메모리에 영향을 미칩니다. static 필드에 데이터가 계속해서 쌓이게 되면 OutOfMemory가 발생할 수도 있습니다. 

 

### 테스트하기 어려움 

- static 필드는 전역으로 관리되기 때문에 프로그램 전체에서 이 필드에 접근할 수 있고 변경할 수 있으므로 해당 필드를 추론하기 어려워 테스트하기가 까다롭습니다.


### static의 장점

그러나 무조건적으로 static의 사용이 나쁘다는 것이 아닙니다. 늘 그렇듯이 올바르게 사용한다면 static은 그 자체로 성능을 향상할 수 있습니다.

예를 들어 자주 사용하지만 절대 변하지 않는 변수, 즉 상수의 경우에는 관례적으로 final static을 사용하여 선언합니다. 이 경우 적어도 1바이트 이상의 GC 대상 객체가 사라지게 됩니다. 

GC가 애초에 대상으로 인식하지 않기 때문에 성능 향상에 도움을 줄 수 있습니다. 

다만 단순히 편리하다는 이유로 잘못 사용하게 되면 의도한 바와 달리 예상하지 못한 문제를 야기할 수도 있습니다.



출처: https://kellis.tistory.com/127 [Flying Whale]
